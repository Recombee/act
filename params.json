{"name":"ACT","tagline":"","body":"### ACT ( Aerospike Certification Test )\r\n\r\nThis project is maintained by [Aerospike](http://www.aerospike.com)\r\n\r\n### Getting started\r\n--------------------\r\n\r\n```\r\n$ git clone git@github.com:aerospike/act.git\r\n$ cd act\r\n$ make\r\n$ make -f Makesalt\r\n```\r\n\r\nThis will create 2 binaries, act and actprep\r\n\r\n* ***actprep***:This executable will basically zeroâ€™s out the drives and fills it up with random data(Salting). Basically to reproduce a normal production state.\r\n* ***act***: The primary executable.\r\n\r\n### Test Process Overview\r\n---------------------\r\n\r\n\r\n1. Clean and initialize the storage device(s).\r\n2. Run the act executable.\r\n3. Analyze act's output using the act_latency.py script.\r\n\r\n\r\n### Caution\r\n-------\r\n\r\nTHE TESTS DESTROY ALL DATA ON THE TEST DEVICES!\r\n\r\nWhen cleaning, initializing, and running tests, make sure the devices are\r\nspecified by name correctly.\r\n\r\nAlso make sure that the test devices are not mounted.\r\n\r\nRun the command:\r\n```\r\n\t$ mount\r\n```\r\nand examine the result.  e.g. the result:\r\n\t/dev/sda1 on /boot type ext3 (rw)\r\nimplies device /dev/sda1 is mounted.\r\n\r\nAlso run the command:\r\n```\r\n\t$ sudo /sbin/pvscan\r\n```\r\nand examine the result.  e.g. the result:\r\n\t  PV /dev/sda2   VG VolGroup00   lvm2 [19.88 GB / 0    free]\r\nimplies device /dev/sda2 is mounted.\r\n\r\nUnmount any intended test devices that are mounted.\r\n\r\n\r\n### Cleaning and Initializing Devices\r\n---------------------------------\r\n\r\nFor consistency, and to obtain test results that model the long-time\r\nequilibrium condition expected in Aerospike production servers, it is best to\r\nprepare storage devices by first cleaning them (writing zeros everywhere) and\r\nthen \"salting\" them (writing random data everywhere).\r\n\r\nThis package contains actprep, an executable that may be used to clean and salt\r\na device.  actprep takes a device name as its only command-line parameter.  For\r\na typical 240GB SSD, actprep takes a little over an hour to run.\r\n\r\nExample - to clean and salt device /dev/sdc: (If Over-Provisioned using hdparm)\r\n```\r\n        $ sudo ./actprep /dev/sdc\r\n```\r\nIf Over-Provisioned using fdisk, make sure you specify the partition and not raw\r\ndevice, if raw device(sdc) is used then it will wipe out the partition table.\r\n```\r\n        $ sudo ./actprep /dev/sdc1\r\n```\r\n\r\n### ACT Overview\r\n------------\r\n\r\nACT is a program for testing storage device IO.  Its primary purpose is to\r\nmeasure the latency of small read transactions while modeling the Aerospike\r\nserver's device IO pattern as closely as practical.\r\n\r\nThese IO patterns will be very similar to many databases focused on real-time\r\nperformance. Databases of this type will constantly read and write from\r\ndisk, without allowing the drive time to rest. This tool very easily shows\r\nlatency responses under write load.\r\n\r\nThree types of IO operations occur during a test run:\r\n\r\n1. Small (~2 Kbyte) read operations, typically several thousand per second.\r\n2. Large-block (~128 Kbyte) read operations, typically a few tens per second.\r\n3. Large-block write operations, same size and rate as large-block reads.\r\n\r\nThe small read operations model client transaction requests.  They occur at a\r\nspecified rate.  Requests are added at this rate to a specified number of\r\nread transaction queues, each of which is serviced by a specified number of\r\nthreads.\r\n\r\nThe large-block read and write operations model the Aerospike server's\r\ndefragmentation process.  They occur at a specified rate, executed from one\r\ndedicated large-block read thread and one dedicated large-block write thread per\r\ndevice.\r\n\r\n### Create Configuration file\r\n-------------------------\r\n\r\nThe repo contains act_config_helper.py which can create configuration file you can\r\nuse to run act, When yoy run this program it will ask you basic questions on test\r\nyou want to run and generate config file at the end of the questions\r\n```\r\n        $ python act_config_helper.py\r\n        ### Answer the questions asked in command line.\r\n```\r\nAlternately you can create config file manually based on instructions below.\r\n\r\n### Using ACT\r\n---------\r\n\r\nNecessary files: act (the executable), plus a configuration text file.\r\n\r\nFor ease of use, this package includes act_config_helper.py for creating config \r\nfiles and also has five example configuration files:\r\n\r\n* actconfig_1x.txt    - run a normal load test on one device\r\n* actconfig_3x.txt    - run a 3 times normal load test on one device\r\n* actconfig_6x.txt    - run a 6 times normal load test on one device\r\n* actconfig_12x.txt   - run a 12 times normal load test on one device\r\n* actconfig_24x.txt   - run a 24 times normal load test on one device\r\n* actconfig_1x_2d.txt - run a normal load test on two devices at a time\r\n*  actconfig_1x_4d.txt - run a normal load test test on four devices at a time\r\n\r\nThese configuration files must be modified to make sure the device-names field\r\n(see below) specifies exactly the device(s) to be tested.\r\n\r\nThe other fields in the configuration files should not be changed without good\r\nreasons.  As they are, the files specify 24-hour tests with IO patterns and\r\nloads very similar to Aerospike production servers.\r\n\r\nUsage example:\r\n```\r\n\t$ sudo ./act actconfig.txt > ouput.txt\r\n```\r\nact outputs to stdout, so for normal (long-duration) tests, pipe to an output\r\nfile as above.  This will be necessary to run the act_latency.py script to\r\nanalyze the output.\r\n\r\nIf running act from a remote terminal, it is best to run it as a background\r\nprocess, or within a \"screen\".  To verify that act is running, tail the output\r\ntext file with the -f option.\r\n\r\nNote that if the drive(s) being tested perform so badly that act's internal\r\ntransaction queues become extremely backed-up, act will halt before the\r\nconfigured test duration has elapsed.  act may also halt prematurely if it\r\nencounters unexpected drive I/O or system errors.\r\n\r\n\r\n### ACT Configuration File\r\n----------------------\r\n\r\nAll fields use a \"name-token: value\" format, and must be on a single line.\r\nField order in the file is unimportant.  Integer values must be in decimal.  To\r\nadd comments, use '#' at the beginning of a line.  The fields are:\r\n\r\n**device-names**\r\nThe value is a comma-separated list of device names (full path), such as\r\n/dev/sdb.  Make absolutely sure the devices named are exactly the devices to be\r\nused in the test.\r\n\r\n**queue-per-device**\r\nThe value is either yes or no.  If the field is left out, the default is no.\r\nThis flag determines act's internal read transaction queue setup -- yes means\r\neach device is read by a single dedicated read transaction queue, no means each\r\ndevice is read by all read transaction queues.\r\n\r\n**num-queues**\r\nThe value is a non-zero integer.  This is the total number of read transaction\r\nqueues.  However if queue-per-device is set to yes, this field is ignored,\r\nsince in this case the number of queues is determined by the number of devices.\r\n\r\n**threads-per-queue**\r\nThe value is a non-zero integer.  This is the number of threads per read\r\ntransaction queue that execute the read transactions.\r\n\r\n**test-duration-sec**\r\nThe value is a non-zero integer.  This is the duration of the test, in seconds.\r\nNote that it has to be a single number, e.g. use 86400, not 60*60*24.\r\n\r\n**report-interval-sec**\r\nThe value is a non-zero integer.  This is the interval between metric reports,\r\nin seconds.\r\n\r\n**read-reqs-per-sec**\r\nThe value is a non-zero integer.  This is the total read transaction rate.  Note\r\nthat it is not per device, or per read transaction queue. e.g. For 2 times (2x)\r\nthe normal load, value would be 2*2000 = 4000. Formula: n x 2000\r\n\r\n**large-block-ops-per-sec**\r\nThe value is a non-zero integer.  This is the total rate used for both\r\nlarge-block write and large-block read operations.  Note that it is not per\r\ndevice. e.g. For 2 times (2x) the normal load, value would be 2*23.5 = 47\r\n(rounded up) Formula: n x 23.5\r\n\r\n**read-req-num-512-blocks**\r\nThe value is a non-zero integer.  This is the size read in each read\r\ntransaction, in 512-byte blocks, e.g. for 1.5-Kbyte reads, use 3.\r\n\r\n**large-block-op-kbytes**\r\nThe value is a non-zero integer.  This is the size written and read in each\r\nlarge-block write and large-block read operation respectively, in Kbytes.\r\n\r\n**use-valloc**\r\nThe value is either yes or no.  If the field is left out, the default is no.\r\nThis flag determines act's memory allocation mechanism for read transaction\r\nbuffers -- yes means a system memory allocation call is used, no means dynamic\r\nstack allocation is used.\r\n\r\n**num-write-buffers**\r\nThe value is an integer.  If the field is left out, the default is 0.  This is\r\nthe number of different large blocks of random data we choose from when doing a\r\nlarge-block write operation -- 0 will cause all zeros to be written every time.\r\n\r\n**scheduler-mode**\r\nThe value is either noop or cfq.  If the field is left out, the default is noop.\r\nThis sets the mode in /sys/block/<device>/queue/scheduler for all the devices in\r\nthe test run -- noop means no special scheduling is done for device IO\r\noperations, cfq means operations may be reordered to optimize for physical\r\nconstraints imposed by rotating disc drives (which likely means it hurts\r\nperformance for ssds).\r\n\r\n\r\n### Analyzing act Output\r\n--------------------\r\n\r\nRun act_latency.py to process a act output file and tabulate data about\r\n\"latencies\" (small read transactions that took longer than usual).\r\n\r\nExample usage:\r\n```\r\n\t$ ./act_latency.py -l output.txt\r\n```\r\n**act_latency.py** command-line parameters:\r\n```\r\n -l <act output file name>\r\n\r\n -t <analysis slice interval in seconds> (default is 3600)\r\n```\r\n(There are two other optional parameters for more advanced use, to control which\r\nlatency thresholds are displayed.)\r\n\r\nThe script will analyze the act output in time slices as specified, and display\r\nlatency data above various thresholds for each slice.  The script output will\r\nshow latencies both for end-to-end transactions (which include time spent on the\r\ntransaction queues) and for the device IO portion of transactions.\r\n\r\nExample **act_latency.py** output (for a act output file yielding 12 slices):\r\n```\r\n         trans                  device\r\n         %>(ms)                 %>(ms)\r\n slice        1      8     64        1      8     64\r\n -----   ------ ------ ------   ------ ------ ------\r\n     1     1.67   0.00   0.00     1.63   0.00   0.00\r\n     2     1.38   0.00   0.00     1.32   0.00   0.00\r\n     3     1.80   0.14   0.00     1.56   0.08   0.00\r\n     4     1.43   0.00   0.00     1.39   0.00   0.00\r\n     5     1.68   0.00   0.00     1.65   0.00   0.00\r\n     6     1.37   0.00   0.00     1.33   0.00   0.00\r\n     7     1.44   0.00   0.00     1.41   0.00   0.00\r\n     8     1.41   0.00   0.00     1.35   0.00   0.00\r\n     9     2.70   0.73   0.00     1.91   0.08   0.00\r\n    10     1.54   0.00   0.00     1.51   0.00   0.00\r\n    11     1.53   0.00   0.00     1.48   0.00   0.00\r\n    12     1.47   0.00   0.00     1.43   0.00   0.00\r\n -----   ------ ------ ------   ------ ------ ------\r\n   avg     1.62   0.07   0.00     1.50   0.01   0.00\r\n   max     2.70   0.73   0.00     1.91   0.08   0.00\r\n```\r\n\r\n### Device Pass/Fail Criteria\r\n-------------------------\r\n\r\nTo deploy a device in production, Aerospike expects it to be able to perform\r\nconsistently as follows:\r\n\r\nIn any one-hour period for normal load , we must find that:\r\n\r\n - fewer than 5% of transactions exceed 1 ms\r\n - fewer than 1% of transactions exceed 8 ms\r\n - fewer than 0.1% of transactions exceed 64 ms\r\n\r\nA device which does not violate these thresholds for 48 hours is considered\r\nproduction-worthy.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}